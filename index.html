import React, { useState } from 'react';
import { CheckCircle, AlertTriangle, Zap, Code, Shield, Rocket } from 'lucide-react';

export default function VirtusImprovements() {
  const [activeCategory, setActiveCategory] = useState('critical');

  const improvements = {
    critical: [
      {
        title: "Segurança das Credenciais Firebase",
        severity: "CRÍTICO",
        icon: Shield,
        color: "text-red-500",
        description: "As credenciais do Firebase estão expostas no código frontend",
        solution: "Implementar Firebase Security Rules e usar variáveis de ambiente",
        code: `// Firestore Security Rules (console do Firebase)
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /usuarios/{userId} {
      // Apenas o próprio usuário pode ler/escrever seus dados
      allow read, write: if request.auth != null 
        && request.auth.uid == userId;
    }
  }
}

// Adicionar limitações de taxa
match /usuarios/{userId} {
  allow write: if request.auth.uid == userId
    && request.time > resource.data.lastWrite + duration.value(1, 's');
}`
      },
      {
        title: "Validação de Dados Inconsistente",
        severity: "ALTO",
        icon: AlertTriangle,
        color: "text-orange-500",
        description: "Faltam validações robustas nos inputs do usuário",
        solution: "Implementar sistema de validação centralizado",
        code: `// validators.js - Adicionar ao seu HTML/JS
const validators = {
  valor: (val) => {
    const num = parseFloat(val);
    if (isNaN(num)) throw new Error('Valor inválido');
    if (num <= 0) throw new Error('Valor deve ser positivo');
    if (num > 999999999) throw new Error('Valor muito alto');
    return num;
  },
  
  email: (email) => {
    const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;
    if (!regex.test(email)) throw new Error('Email inválido');
    return email.toLowerCase().trim();
  },
  
  descricao: (desc) => {
    if (!desc || desc.trim().length < 3) {
      throw new Error('Descrição muito curta (mín. 3 caracteres)');
    }
    if (desc.length > 200) {
      throw new Error('Descrição muito longa (máx. 200 caracteres)');
    }
    return desc.trim();
  },
  
  data: (dateStr) => {
    const date = new Date(dateStr);
    if (isNaN(date.getTime())) throw new Error('Data inválida');
    return dateStr;
  }
};

// Uso nas funções existentes
window.adicionarGeral = function() {
  try {
    const desc = validators.descricao(document.getElementById('f-desc').value);
    const valor = validators.valor(document.getElementById('f-valor').value);
    const data = validators.data(document.getElementById('f-data').value);
    
    // ... resto do código
  } catch (error) {
    showToast(error.message, 'error');
    return;
  }
};`
      },
      {
        title: "Gerenciamento de Estado Inadequado",
        severity: "MÉDIO",
        icon: Code,
        color: "text-yellow-500",
        description: "Estado global em variável simples dificulta manutenção e debug",
        solution: "Implementar sistema de eventos observável",
        code: `// state-manager.js
class StateManager {
  constructor() {
    this.state = { trans: [], invest: [], metas: [], historico: [] };
    this.listeners = [];
  }

  getState() {
    return JSON.parse(JSON.stringify(this.state));
  }

  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.notify();
  }

  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }

  notify() {
    this.listeners.forEach(listener => listener(this.state));
  }

  addTransaction(trans) {
    this.state.trans.push(trans);
    this.notify();
  }

  removeTransaction(index) {
    this.state.trans.splice(index, 1);
    this.notify();
  }
}

// Uso
const stateManager = new StateManager();

stateManager.subscribe((state) => {
  console.log('Estado atualizado:', state);
  atualizarUI();
});

stateManager.addTransaction({ desc: 'Teste', valor: 100 });`
      },
      {
        title: "Tratamento de Erros Inadequado",
        severity: "ALTO",
        icon: AlertTriangle,
        color: "text-orange-500",
        description: "Erros não são capturados adequadamente em operações async",
        solution: "Implementar error boundaries e retry logic",
        code: `// error-handler.js
async function withRetry(fn, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      
      // Exponential backoff
      await new Promise(resolve => 
        setTimeout(resolve, Math.pow(2, i) * 1000)
      );
    }
  }
}

// Melhorar carregarCloud()
async function carregarCloud() {
  if (!currentUser) return;
  
  try {
    const docRef = doc(dbCloud, "usuarios", currentUser.uid);
    
    const snap = await withRetry(async () => {
      return await getDoc(docRef);
    });
    
    if (snap.exists()) {
      db = snap.data();
      if (!db.historico) db.historico = [];
    } else {
      db = { trans: [], invest: [], metas: [], historico: [] };
      await salvarCloud();
    }
    
    atualizarTudo();
  } catch (error) {
    console.error('Erro ao carregar dados:', error);
    showToast('Erro ao carregar. Tentando novamente...', 'error');
    
    // Fallback para dados locais se existirem
    const localData = localStorage.getItem('virtus-backup');
    if (localData) {
      db = JSON.parse(localData);
      showToast('Usando dados locais', 'warning');
    }
  }
}`
      }
    ],
    performance: [
      {
        title: "Otimização de Renderizações",
        severity: "MÉDIO",
        icon: Zap,
        color: "text-blue-500",
        description: "Componentes re-renderizam desnecessariamente",
        solution: "Implementar debounce e virtual scrolling",
        code: `// utils.js
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

function throttle(func, limit) {
  let inThrottle;
  return function(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

// Aplicar no atualizarTudo
window.atualizarTudo = debounce(function() {
  // ... código existente
}, 300);

// Para scrolling pesado
function renderVisibleItems(items, container, itemHeight) {
  const scrollTop = container.scrollTop;
  const viewportHeight = container.clientHeight;
  
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.ceil((scrollTop + viewportHeight) / itemHeight);
  
  return items.slice(startIndex, endIndex + 1);
}`
      },
      {
        title: "Carregamento de Charts Pesado",
        severity: "MÉDIO",
        icon: Zap,
        color: "text-blue-500",
        description: "Charts são recriados a cada atualização desnecessariamente",
        solution: "Implementar cache de dados e lazy loading",
        code: `// chart-manager.js
const chartCache = new Map();

function updateChart(chartId, newData) {
  const cachedData = chartCache.get(chartId);
  
  // Comparar dados para evitar re-render
  if (cachedData && JSON.stringify(cachedData) === JSON.stringify(newData)) {
    return; // Dados não mudaram
  }
  
  chartCache.set(chartId, newData);
  
  if (chartInstance) {
    // Atualizar ao invés de recriar
    chartInstance.data = newData;
    chartInstance.update('none'); // Sem animação
  } else {
    // Criar novo chart
    createChart(chartId, newData);
  }
}

// Intersection Observer para lazy load
const chartObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const chartId = entry.target.id;
      loadChart(chartId);
      chartObserver.unobserve(entry.target);
    }
  });
});

document.querySelectorAll('canvas').forEach(canvas => {
  chartObserver.observe(canvas);
});`
      },
      {
        title: "Otimizar Salvamento no Cloud",
        severity: "ALTO",
        icon: Zap,
        color: "text-orange-500",
        description: "Cada alteração salva imediatamente no Firestore",
        solution: "Implementar batching e salvamento periódico",
        code: `// sync-manager.js
class SyncManager {
  constructor() {
    this.pendingChanges = [];
    this.syncInterval = null;
    this.isSyncing = false;
  }

  queueChange(change) {
    this.pendingChanges.push({
      ...change,
      timestamp: Date.now()
    });
    
    // Salvar localmente imediatamente
    this.saveLocal();
    
    // Iniciar sync automático se não estiver rodando
    if (!this.syncInterval) {
      this.startAutoSync();
    }
  }

  saveLocal() {
    localStorage.setItem('virtus-backup', JSON.stringify(db));
    localStorage.setItem('virtus-pending', JSON.stringify(this.pendingChanges));
  }

  async syncToCloud() {
    if (this.isSyncing || this.pendingChanges.length === 0) return;
    
    this.isSyncing = true;
    
    try {
      await salvarCloud();
      this.pendingChanges = [];
      localStorage.removeItem('virtus-pending');
    } catch (error) {
      console.error('Erro ao sincronizar:', error);
    } finally {
      this.isSyncing = false;
    }
  }

  startAutoSync() {
    // Sincronizar a cada 30 segundos
    this.syncInterval = setInterval(() => {
      this.syncToCloud();
    }, 30000);
  }

  stopAutoSync() {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
      this.syncInterval = null;
    }
  }
}

const syncManager = new SyncManager();

// Usar no lugar de salvarCloud direto
window.adicionarGeral = function() {
  // ... validações
  db.trans.push({ desc, valor, data, tipo, parc: 1, pago: tipo === 'Receita' });
  syncManager.queueChange({ type: 'ADD_TRANSACTION' });
  atualizarTudo();
};`
      }
    ],
    features: [
      {
        title: "Sistema de Backup Automático",
        severity: "NOVO",
        icon: Rocket,
        color: "text-purple-500",
        description: "Backup automático dos dados em múltiplos locais",
        solution: "localStorage + download periódico",
        code: `// backup-manager.js
class BackupManager {
  constructor() {
    this.lastBackup = null;
    this.startAutoBackup();
  }

  createBackup() {
    const backup = {
      version: '1.0',
      timestamp: new Date().toISOString(),
      data: db,
      checksum: this.generateChecksum(db)
    };
    
    // Salvar em localStorage
    localStorage.setItem('virtus-backup', JSON.stringify(backup));
    
    // Manter histórico dos últimos 5 backups
    const history = JSON.parse(
      localStorage.getItem('virtus-backup-history') || '[]'
    );
    history.unshift(backup);
    history.splice(5); // Manter só 5
    localStorage.setItem('virtus-backup-history', JSON.stringify(history));
    
    this.lastBackup = Date.now();
    return backup;
  }

  generateChecksum(data) {
    // Simples hash para integridade
    const str = JSON.stringify(data);
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash.toString(36);
  }

  downloadBackup() {
    const backup = this.createBackup();
    const blob = new Blob([JSON.stringify(backup, null, 2)], 
      { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = \`virtus-backup-\${new Date().toISOString().split('T')[0]}.json\`;
    a.click();
    URL.revokeObjectURL(url);
  }

  restoreBackup(backupData) {
    if (this.generateChecksum(backupData.data) !== backupData.checksum) {
      throw new Error('Backup corrompido - checksum inválido');
    }
    
    db = backupData.data;
    salvarCloud();
    atualizarTudo();
    showToast('Backup restaurado com sucesso!', 'success');
  }

  startAutoBackup() {
    // Backup automático a cada 5 minutos
    setInterval(() => {
      if (Date.now() - this.lastBackup > 300000) {
        this.createBackup();
      }
    }, 60000);
  }
}

const backupManager = new BackupManager();`
      },
      {
        title: "Modo Offline Básico",
        severity: "NOVO",
        icon: Rocket,
        color: "text-purple-500",
        description: "Permitir uso básico sem conexão",
        solution: "Detectar offline e usar localStorage",
        code: `// offline-manager.js
class OfflineManager {
  constructor() {
    this.isOnline = navigator.onLine;
    this.setupListeners();
  }

  setupListeners() {
    window.addEventListener('online', () => {
      this.isOnline = true;
      this.syncPendingChanges();
      showToast('Conexão restaurada! Sincronizando...', 'success');
    });

    window.addEventListener('offline', () => {
      this.isOnline = false;
      showToast('Modo offline ativado', 'warning');
    });
  }

  async syncPendingChanges() {
    const pending = localStorage.getItem('virtus-pending-sync');
    if (!pending) return;

    try {
      const changes = JSON.parse(pending);
      for (const change of changes) {
        await this.applyChange(change);
      }
      localStorage.removeItem('virtus-pending-sync');
      showToast('Dados sincronizados!', 'success');
    } catch (error) {
      console.error('Erro ao sincronizar:', error);
      showToast('Erro na sincronização', 'error');
    }
  }

  queueForSync(change) {
    const pending = JSON.parse(
      localStorage.getItem('virtus-pending-sync') || '[]'
    );
    pending.push({
      ...change,
      timestamp: Date.now()
    });
    localStorage.setItem('virtus-pending-sync', JSON.stringify(pending));
  }

  async save(data) {
    // Sempre salvar localmente
    localStorage.setItem('virtus-data', JSON.stringify(data));

    if (this.isOnline) {
      try {
        await salvarCloud();
      } catch (error) {
        console.error('Erro ao salvar na nuvem:', error);
        this.queueForSync({ type: 'SAVE', data });
      }
    } else {
      this.queueForSync({ type: 'SAVE', data });
    }
  }
}

const offlineManager = new OfflineManager();`
      },
      {
        title: "Exportação Avançada (CSV)",
        severity: "NOVO",
        icon: Rocket,
        color: "text-purple-500",
        description: "Exportar dados em formato CSV para Excel",
        solution: "Gerar CSV manualmente sem bibliotecas externas",
        code: `// export-manager.js
function exportToCSV(data, filename) {
  // Converter dados para CSV
  const headers = Object.keys(data[0]);
  const csvContent = [
    headers.join(','),
    ...data.map(row => 
      headers.map(header => {
        const value = row[header];
        // Escapar vírgulas e aspas
        if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
          return '"' + value.replace(/"/g, '""') + '"';
        }
        return value;
      }).join(',')
    )
  ].join('\\n');

  // Download
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.click();
  URL.revokeObjectURL(url);
}

function exportarRelatorio() {
  // Preparar dados das transações
  const transacoesCSV = db.trans.map(t => ({
    'Data': t.data,
    'Descrição': t.desc,
    'Valor': t.valor.toFixed(2),
    'Tipo': t.tipo,
    'Status': t.pago ? 'Pago' : 'Pendente'
  }));

  exportToCSV(transacoesCSV, \`virtus-transacoes-\${new Date().toISOString().split('T')[0]}.csv\`);

  // Investimentos
  const investCSV = db.invest.map(inv => ({
    'Ativo': inv.onde,
    'Valor': inv.valor.toFixed(2),
    'Taxa Mensal': ((inv.taxa || 0) * 100).toFixed(2) + '%',
    'Categoria': inv.tipo,
    'Rendimento Mensal': (inv.valor * (inv.taxa || 0)).toFixed(2)
  }));

  exportToCSV(investCSV, \`virtus-investimentos-\${new Date().toISOString().split('T')[0]}.csv\`);
  
  showToast('Relatórios exportados!', 'success');
}`
      },
      {
        title: "Dashboard de Análises Avançado",
        severity: "NOVO",
        icon: Rocket,
        color: "text-purple-500",
        description: "Adicionar análises e insights automáticos",
        solution: "Calcular métricas e gerar insights",
        code: `// analytics.js
function gerarInsights() {
  const insights = [];
  
  // Calcular médias
  const gastosUltimos30Dias = db.trans
    .filter(t => t.tipo !== 'Receita')
    .filter(t => {
      const diff = Date.now() - new Date(t.data).getTime();
      return diff < 30 * 24 * 60 * 60 * 1000;
    })
    .reduce((sum, t) => sum + t.valor, 0);

  const mediaGastoDiario = gastosUltimos30Dias / 30;

  // Insight 1: Gastos acima da média
  if (mediaGastoDiario > 100) {
    insights.push({
      tipo: 'warning',
      titulo: 'Gastos Elevados',
      mensagem: \`Sua média diária de R$ \${mediaGastoDiario.toFixed(2)} está acima do recomendado\`,
      acao: 'Revisar gastos diários'
    });
  }

  // Insight 2: Metas próximas
  const metasProximas = db.metas?.filter(m => {
    const progresso = (m.atual / m.valor) * 100;
    return progresso >= 80 && progresso < 100;
  }) || [];

  if (metasProximas.length > 0) {
    insights.push({
      tipo: 'success',
      titulo: 'Metas Próximas!',
      mensagem: \`Você está perto de alcançar \${metasProximas.length} meta(s)!\`,
      acao: 'Ver metas'
    });
  }

  // Insight 3: Diversificação de investimentos
  if (db.invest.length > 0) {
    const tiposInvest = new Set(db.invest.map(i => i.tipo));
    if (tiposInvest.size === 1) {
      insights.push({
        tipo: 'info',
        titulo: 'Diversifique seus Investimentos',
        mensagem: 'Considere diversificar em diferentes categorias',
        acao: 'Ver sugestões'
      });
    }
  }

  return insights;
}

// Renderizar insights
function renderizarInsights() {
  const insights = gerarInsights();
  const container = document.getElementById('insights-container');
  
  container.innerHTML = insights.map(insight => \`
    <div class="section-box" style="border-left: 4px solid var(--accent-\${
      insight.tipo === 'warning' ? 'warning' :
      insight.tipo === 'success' ? 'success' : 'primary'
    })">
      <h4 style="margin-bottom: 8px; color: var(--accent-\${
        insight.tipo === 'warning' ? 'warning' :
        insight.tipo === 'success' ? 'success' : 'primary'
      })">\${insight.titulo}</h4>
      <p style="color: var(--text-dim); margin-bottom: 12px;">\${insight.mensagem}</p>
      <button class="btn btn-secondary" style="width: auto;">
        \${insight.acao} <i class="fa-solid fa-arrow-right"></i>
      </button>
    </div>
  \`).join('');
}`
      }
    ],
    ux: [
      {
        title: "Feedback Visual Melhorado",
        severity: "MÉDIO",
        icon: CheckCircle,
        color: "text-green-500",
        description: "Adicionar estados de loading e animações suaves",
        solution: "Implementar skeleton screens e loading states",
        code: `// loading-states.js
function showSkeleton(containerId, count = 3) {
  const container = document.getElementById(containerId);
  container.innerHTML = Array(count).fill('').map(() => \`
    <div class="skeleton-card">
      <div class="skeleton-line" style="width: 70%; height: 20px;"></div>
      <div class="skeleton-line" style="width: 40%; height: 16px; margin-top: 12px;"></div>
      <div class="skeleton-line" style="width: 90%; height: 14px; margin-top: 8px;"></div>
    </div>
  \`).join('');
}

// CSS adicional
.skeleton-card {
  background: var(--card-bg);
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 12px;
}

.skeleton-line {
  background: linear-gradient(
    90deg,
    rgba(255,255,255,0.05) 25%,
    rgba(255,255,255,0.1) 50%,
    rgba(255,255,255,0.05) 75%
  );
  background-size: 200% 100%;
  animation: shimmer 1.5s infinite;
  border-radius: 6px;
}

@keyframes shimmer {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}

// Usar antes de carregar dados
showSkeleton('lista-invest');
// ... carregar dados
// ... atualizar com dados reais`
      },
      {
        title: "Acessibilidade (a11y)",
        severity: "MÉDIO",
        icon: CheckCircle,
        color: "text-green-500",
        description: "Melhorar navegação por teclado e screen readers",
        solution: "Adicionar ARIA labels e suporte a teclado",
        code: `// Melhorar botões existentes
function criarStatsCard(desc, valor, tipo, index, icon) {
  return \`
    <div class="stats-card" role="article" aria-label="Transação: \${desc}">
      <div style="flex: 1;">
        <div style="font-weight: 600;">\${icon} \${desc}</div>
        <div style="color: var(--accent-danger); font-size: 1.1rem; margin-top: 4px;">
          \${formatar(valor)}
        </div>
      </div>
      <button 
        class="btn-icon" 
        onclick="remover('\${tipo}', \${index})"
        aria-label="Remover \${desc}"
        title="Remover transação"
      >
        <i class="fa-solid fa-trash" aria-hidden="true"></i>
      </button>
    </div>
  \`;
}

// Adicionar navegação por teclado
document.addEventListener('keydown', (e) => {
  // Ctrl/Cmd + N = Nova transação
  if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
    e.preventDefault();
    document.getElementById('f-desc').focus();
  }
  
  // Ctrl/Cmd + S = Salvar/Sync
  if ((e.ctrlKey || e.metaKey) && e.key === 's') {
    e.preventDefault();
    syncManager.syncToCloud();
    showToast('Salvando...', 'info');
  }
  
  // Esc = Fechar modal
  if (e.key === 'Escape') {
    const modals = document.querySelectorAll('.modal-overlay');
    modals.forEach(m => m.style.display = 'none');
  }
});

// Anunciar mudanças para screen readers
function anunciar(mensagem) {
  const announcer = document.getElementById('sr-announcer') || (() => {
    const el = document.createElement('div');
    el.id = 'sr-announcer';
    el.setAttribute('aria-live', 'polite');
    el.setAttribute('aria-atomic', 'true');
    el.style.cssText = 'position:absolute;left:-10000px;width:1px;height:1px;overflow:hidden;';
    document.body.appendChild(el);
    return el;
  })();
  
  announcer.textContent = mensagem;
}`
      },
      {
        title: "Modo Escuro/Claro",
        severity: "BAIXO",
        icon: CheckCircle,
        color: "text-green-500",
        description: "Adicionar alternância entre temas",
        solution: "Sistema de temas com CSS variables",
        code: `// theme-manager.js
const themes = {
  dark: {
    '--bg-dark': '#0a0a0f',
    '--bg-medium': '#13131a',
    '--card-bg': '#1a1a24',
    '--text-main': '#f5f5f7',
    '--text-dim': '#9999a8'
  },
  light: {
    '--bg-dark': '#f5f5f7',
    '--bg-medium': '#ffffff',
    '--card-bg': '#ffffff',
    '--text-main': '#0a0a0f',
    '--text-dim': '#5d5d6b'
  }
};

function setTheme(themeName) {
  const theme = themes[themeName];
  const root = document.documentElement;
  
  Object.keys(theme).forEach(property => {
    root.style.setProperty(property, theme[property]);
  });
  
  localStorage.setItem('virtus-theme', themeName);
}

function toggleTheme() {
  const currentTheme = localStorage.getItem('virtus-theme') || 'dark';
  const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
  setTheme(newTheme);
  
  // Animar transição
  document.body.style.transition = 'background-color 0.3s ease';
}

// Adicionar botão de toggle no sidebar
const themeToggle = \`
  <button 
    class="btn btn-secondary" 
    onclick="toggleTheme()"
    aria-label="Alternar tema"
  >
    <i class="fa-solid fa-moon"></i>
    Tema
  </button>
\`;

// Inicializar tema salvo
const savedTheme = localStorage.getItem('virtus-theme') || 'dark';
setTheme(savedTheme);`
      }
    ]
  };

  const categories = [
    { id: 'critical', label: 'Críticas', icon: Shield },
    { id: 'performance', label: 'Performance', icon: Zap },
    { id: 'features', label: 'Novas Features', icon: Rocket },
    { id: 'ux', label: 'UX/UI', icon: CheckCircle }
  ];

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-950 to-slate-900 text-white p
